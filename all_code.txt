package chkGameUtil;

import chkMVC.chModel.Checkers.BoardModel;

public class BoardHelperSingleton {
    private static BoardHelperSingleton instance;
    private BoardModel gameBoardModel;

    // Private constructor to prevent external instantiation
    private BoardHelperSingleton(int boardSize) {
        this.gameBoardModel = new BoardModel(boardSize);
    }

    // Method to initialize the instance
    public static void initialize(int boardSize) {
        if (instance == null) {
            instance = new BoardHelperSingleton(boardSize);
        } else {
            throw new IllegalStateException("Game has already been initialized.");
        }
    }

    // Method to get the singleton instance
    public static BoardHelperSingleton getInstance() {
        if (instance == null) {
            throw new IllegalStateException("Game has not been initialized. Call initialize(width, height) first.");
        }
        return instance;
    }

    public int getBoardWidth() {
        return gameBoardModel.getWidth();
    }

    public int getBoardHeight() {
        return gameBoardModel.getHeight();
    }


    public BoardModel getBoard() {
        return gameBoardModel;
    }


    //CLose out the board and reset the instance to nulllllllllllllllllllllll
    public void closeBoard()
    {
        if(gameBoardModel != null)
        {
            gameBoardModel.clearBoard();
            gameBoardModel = null;
        }

        instance = null;
    }
}

package chkGameUtil;

public class IncrementerSingleton {
    private static IncrementerSingleton instance;
    private int i = 0; // Counter

    // Private constructor prevents direct instantiation
    private IncrementerSingleton() {}

    // Public method to get the singleton instance
    public static IncrementerSingleton getInstance() {
        if (instance == null) {
            instance = new IncrementerSingleton();
        }
        return instance;
    }

    // Method to increment and return the value
    public int increment() {
        return ++i;
    }

    // Method to get the current value
    public int getValue() {
        return i;
    }
}
package chkMVC;

public class CheckersBoard {
}
package chkMVC.chController;

import chkMVC.chModel.Checkers.Pieces.AbstractPiece;
import chkMVC.chModel.Checkers.Position;

//I dont think that users should be able to
public interface BoardController {

    void MovePiece(AbstractPiece piece, Position newPosition); //Function that takes a piece and set new position.
    //Function to get the piece at a position.
    AbstractPiece getPieceAt(Position position);
    //Return the other thing i guess.............
    boolean isPositionOccupied(Position position);
}
package chkMVC.chModel.Checkers;

import chkMVC.chModel.Checkers.Pieces.AbstractPiece;
import chkMVC.chModel.Checkers.Position;
import chkMVC.chModel.Math.Vector2i;

import java.util.HashMap;
import java.util.Map; // Use interface type
import java.util.Optional; // Better way to handle potentially null pieces

public class BoardModel {

    private final Map<Position, AbstractPiece> boardSpace; // Use Map interface
    private final int width;
    private final int height;

    public BoardModel(int size) {
        this(size, size); // Square board constructor
    }

    public BoardModel(int width, int height) {
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Board dimensions must be positive.");
        }
        this.width = width;
        this.height = height;
        this.boardSpace = new HashMap<>();
        // TODO: Add initial piece setup logic here if needed
    }

    public int getWidth() {
        return this.width;
    }

    public int getHeight() {
        return this.height;
    }

    public int getNumberOfPieces() {
        return boardSpace.size();
    }

    // Get piece using Optional to avoid null checks elsewhere
    public Optional<AbstractPiece> getPieceOptional(Position position) {
        // Validate position belongs to this board conceptually
        if (position.getBoardWidth() != this.width || position.getBoardHeight() != this.height) {
            // Or log a warning, depending on desired strictness
            throw new IllegalArgumentException("Position " + position + " dimensions do not match board dimensions (" + width + "x" + height + ")");
        }
        return Optional.ofNullable(boardSpace.get(position));
    }

    // Get piece, returning null (less safe, but sometimes needed)
    public AbstractPiece getPieceAt(Position position) {
        if (position.getBoardWidth() != this.width || position.getBoardHeight() != this.height) {
            throw new IllegalArgumentException("Position dimensions mismatch");
        }
        return boardSpace.get(position);
    }


    public boolean isOccupied(Position position) {
        if (position.getBoardWidth() != this.width || position.getBoardHeight() != this.height) {
            throw new IllegalArgumentException("Position dimensions mismatch");
        }
        return boardSpace.containsKey(position);
    }

    // Internal method to place a piece - used during setup or potentially moves
    // Consider making this package-private or protected if only specific classes should use it
    public void placePiece(AbstractPiece piece) {
        Position pos = piece.getPosition();
        if (pos.getBoardWidth() != this.width || pos.getBoardHeight() != this.height) {
            throw new IllegalArgumentException("Piece position dimensions mismatch");
        }
        if (isOccupied(pos)) {
            throw new IllegalStateException("Cannot place piece at " + pos + ", already occupied by " + boardSpace.get(pos));
        }
        boardSpace.put(pos, piece);
    }

    // Removes a piece - returns true if a piece was removed
    public boolean removePiece(Position position) {
        if (position.getBoardWidth() != this.width || position.getBoardHeight() != this.height) {
            throw new IllegalArgumentException("Position dimensions mismatch");
        }
        return boardSpace.remove(position) != null;
    }

    // Moves a piece - handles removal and placement, checks if 'from' is occupied
    public void movePiece(Position from, Position to) {
        if (from.equals(to)) {
            throw new IllegalArgumentException("Cannot move piece to the same position: " + from);
        }
        AbstractPiece piece = getPieceAt(from);
        if (piece == null) {
            throw new IllegalStateException("No piece found at starting position: " + from);
        }
        if (isOccupied(to)) {
            throw new IllegalStateException("Cannot move to occupied position: " + to);
        }

        // Remove from old, place at new, update piece's internal state
        boardSpace.remove(from);
        boardSpace.put(to, piece);
        piece.setPositionInternal(to); // Update the piece's internal position
    }


    @Override
    public String toString() {
        // Basic toString, printBoard is better for visualization
        return "BoardModel{" +
                "width=" + width +
                ", height=" + height +
                ", pieces=" + boardSpace.size() +
                '}';
    }

    // Using for debugging... (Keep this for testing/console use)
    public void printBoard() {
        System.out.println("Board State (" + width + "x" + height + "):");
        // Assuming (1,1) is top-left for printing
        // Column Headers (A, B, C...)
        System.out.print("  ");
        for (int j = 0; j < width; j++) {
            System.out.print(" " + (char)('A' + j));
        }
        System.out.println();
        System.out.print("  ");
        for (int j = 0; j < width; j++) {
            System.out.print("--");
        }
        System.out.println("-");


        for (int i = 1; i <= height; i++) { // Rows 1 to height
            System.out.printf("%d|", i); // Row label

            for (int j = 1; j <= width; j++) { // Columns 1 to width
                try {
                    Position currentPos = new Position(j, i, width, height);
                    Optional<AbstractPiece> pieceOpt = getPieceOptional(currentPos);
                    if (pieceOpt.isPresent()) {
                        AbstractPiece piece = pieceOpt.get();
                        System.out.print(" " + (piece.getTeam() == AbstractPiece.PEICE_TEAM.WHITE ? 'W' : 'B'));
                    } else {
                        // Checkerboard pattern (optional, can just print '.')
                        // if ((i + j) % 2 == 0) System.out.print(" #"); // Dark square
                        // else System.out.print(" .");                 // Light square
                        System.out.print(" .");
                    }
                } catch(IllegalArgumentException e) {
                    System.out.print(" X"); // Should not happen if loop is correct
                }
            }
            System.out.println(" |"); // End of row
        }
        System.out.print("  ");
        for (int j = 0; j < width; j++) {
            System.out.print("--");
        }
        System.out.println("-");
    }

    public void clearBoard() {
        boardSpace.clear();
    }

    public Vector2i getSize() {
        return new Vector2i(this.getWidth(), this.getHeight());
    }

    public Position createPosition(int x, int y)
    {
        //Create the position based from the baord.
        return new Position(x, y, this.width, this.height);
    }

    /**
     * Converts a 0-based linear integer index (e.g., from a flattened array or UI grid)
     * to a 1-based (x, y) Position object for a board of given dimensions.
     * Assumes row-major order (0 is top-left, width-1 is top-right).
     *
     * @param linearInt The 0-based linear index (0 to width*height - 1).
     * @return The corresponding Position object.
     * @throws IllegalArgumentException if linearInt is out of range [0, width*height - 1]
     *         or if board dimensions are invalid.
     */
    public Position positionFromInt(int linearInt) {
        int boardHeight = this.getHeight();
        int boardWidth = this.getWidth();

        if (boardHeight <= 0 || boardWidth <= 0) {
            throw new IllegalArgumentException("Board dimensions must be positive.");
        }

        int maxIndex = boardWidth * boardHeight - 1;
        if (linearInt < 0 || linearInt > maxIndex) {
            throw new IllegalArgumentException(String.format(
                    "Linear index %d is out of range [0, %d] for a %dx%d board.",
                    linearInt, maxIndex, boardWidth, boardHeight));
        }

        // Calculate 0-based row and column
        int zeroBasedRow = linearInt / boardWidth;  // Row (0 to height-1)
        int zeroBasedCol = linearInt % boardWidth;  // Column (0 to width-1)

        // Convert to 1-based coordinates
        int xValue = zeroBasedCol + 1;
        int yValue = boardHeight - zeroBasedRow;  // If board is inverted (A1 at bottom)

        // Create position with board validation
        return new Position(xValue, yValue, boardWidth, boardHeight);
    }


    // Creates a deep copy for passing state around immutably if needed
    // Note: This requires AbstractPiece subclasses to have copy constructors or similar
    /*
    public BoardModel copy() {
        BoardModel newBoard = new BoardModel(this.width, this.height);
        for (Map.Entry<Position, AbstractPiece> entry : this.boardSpace.entrySet()) {
             // Assuming AbstractPiece has a copy() method or copy constructor
             // newBoard.placePiece(entry.getValue().copy());
        }
        return newBoard;
    }
    */
}
package chkMVC.chModel.Checkers;

import chkMVC.chModel.Math.Vector2i;
import java.util.Objects; // Use Objects.hash

public class Position {
    private final Vector2i position; // Made final
    private final int boardWidth;    // Made final
    private final int boardHeight;   // Made final

    /**
     * Creates a new Position.
     * @param x The x-coordinate (column), 1-based.
     * @param y The y-coordinate (row), 1-based.
     * @param boardWidth The width of the board this position belongs to.
     * @param boardHeight The height of the board this position belongs to.
     * @throws IllegalArgumentException if x or y are out of board bounds [1, width/height].
     */
    public Position(int x, int y, int boardWidth, int boardHeight) {
        if (boardWidth <= 0 || boardHeight <= 0) {
            throw new IllegalArgumentException("Board dimensions must be positive.");
        }
        this.boardWidth = boardWidth;
        this.boardHeight = boardHeight;

        // Validate coordinates against the provided bounds immediately
        if (!isValidCoordinate(x, this.boardWidth)) {
            throw new IllegalArgumentException(String.format(
                    "Invalid x position: %d. Must be between 1 and %d.", x, this.boardWidth));
        }
        if (!isValidCoordinate(y, this.boardHeight)) {
            throw new IllegalArgumentException(String.format(
                    "Invalid y position: %d. Must be between 1 and %d.", y, this.boardHeight));
        }

        this.position = new Vector2i(x, y);
    }

    /**
     * Creates a new Position using Vector2i for coordinates and dimensions.
     * @param positionVector Vector containing 1-based x and y coordinates.
     * @param boardSizeVector Vector containing board width and height.
     * @throws IllegalArgumentException if coordinates are out of bounds.
     */
    public Position(Vector2i positionVector, Vector2i boardSizeVector) {
        this(positionVector.x, positionVector.y, boardSizeVector.x, boardSizeVector.y);
    }

    // Private helper for coordinate validation
    private boolean isValidCoordinate(int value, int maxValue) {
        return value >= 1 && value <= maxValue;
    }

    // No setters needed as fields are final, promoting immutability

    public int getBoardWidth() {
        return this.boardWidth;
    }

    public int getBoardHeight() {
        return this.boardHeight;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Position other = (Position) obj;
        // Positions are equal if coordinates are the same.
        // Board dimensions don't strictly need to match for equality,
        // but logically they should represent the same conceptual square.
        return this.getX() == other.getX() && this.getY() == other.getY();
        // Optional stricter check: && this.boardWidth == other.boardWidth && this.boardHeight == other.boardHeight;
    }

    @Override
    public int hashCode() {
        // Hash code depends only on coordinates for map lookups.
        return Objects.hash(this.getX(), this.getY());
        // Optional stricter hash: return Objects.hash(this.getX(), this.getY(), this.boardWidth, this.boardHeight);
    }

    @Override
    public String toString() {
        // Convert x to letters (A, B, ...)
        char column = (char) ('A' + this.getX() - 1); // Adjust for 1-based index
        // Row is just the Y value
        int row = this.getY();
        // Return standard algebraic notation e.g., "A1", "H8"
        return String.format("%c%d", column, row);
    }

    /**
     * Calculates a new Position relative to this one.
     * @param dx Change in x-coordinate.
     * @param dy Change in y-coordinate.
     * @return The new Position.
     * @throws IllegalArgumentException if the resulting coordinates are off the board.
     */
    public Position getDeltaPosition(int dx, int dy) {
        int newX = this.getX() + dx;
        int newY = this.getY() + dy;
        // The constructor will validate the new coordinates against the board dimensions
        return new Position(newX, newY, this.boardWidth, this.boardHeight);
    }

    /**
     * Calculates a new Position relative to this one using a Vector2i delta.
     * @param dv Vector representing the change in x and y.
     * @return The new Position.
     * @throws IllegalArgumentException if the resulting coordinates are off the board.
     */
    public Position getDeltaPosition(Vector2i dv) {
        return getDeltaPosition(dv.x, dv.y);
    }

    public int getY() {
        return this.position.y;
    }

    public int getX() {
        return this.position.x;
    }
}
package chkMVC.chModel.Checkers.Pieces;

import chkGameUtil.BoardHelperSingleton;
import chkGameUtil.IncrementerSingleton;
import chkMVC.chModel.Checkers.BoardModel;
import chkMVC.chModel.Checkers.Position;
import chkMVC.chModel.Math.Vector2i;

import java.util.ArrayList;
import java.util.List;

public abstract class AbstractPiece {




    private int id;
    private Position position;
    protected PIECE_DIRECTION direction;
    protected PEICE_TEAM team;



    AbstractPiece(Position position, PEICE_TEAM team)
    {
        this.id = IncrementerSingleton.getInstance().increment();
        this.position = position;
        this.direction = (team == PEICE_TEAM.WHITE) ? PIECE_DIRECTION.FORWARD : PIECE_DIRECTION.BACKWARD;
        this.team = team;
    }

    //Will need a recursive function to build up all possible moves. going to need a lot of testing for that.
    public ArrayList<Position> getRecursiveValidPositions()
    {
        return null;
    }

    //Return the valid positions.
    public ArrayList<Position> getValidPositions() {
        Position currentPosition = this.getPosition();
        Position positionOption1 = currentPosition.getDeltaPosition(1, this.direction.value);
        Position positionOption2 = currentPosition.getDeltaPosition(-1, this.direction.value);

        BoardModel gameBoardModel = BoardHelperSingleton.getInstance().getBoard();

        ArrayList<Position> validPositions = new ArrayList<>();

        if(!gameBoardModel.isOccupied(positionOption1)) validPositions.add(positionOption1);
        if(!gameBoardModel.isOccupied(positionOption2)) validPositions.add(positionOption2);

        return validPositions;
    }

    public Position getPosition() {
        return position;
    }

    public int getId() {
        return id;
    }

    public void move(Vector2i delta) {

        Position newPosition = position.getDeltaPosition(delta);

        if (!isValidMove( newPosition)) {  // Assuming
            throw new IllegalArgumentException("Invalid move: " + delta);
        }

        this.position = newPosition;
    }


    public PEICE_TEAM getTeam() {
        return this.team;
    }

    public abstract List<Position> getValidSimpleMoves(BoardModel board);

    public abstract List<Position> getValidJumpMoves(BoardModel board);

    public void setPositionInternal(Position to) {
        this.position = to;
    }

    //Provides info on the cardinal direction of the piece....
    //Just means that when dealing with y axis stuff things are easier.
    public enum PIECE_DIRECTION {
        FORWARD(1),
        BACKWARD(-1);

        private final int value;

        PIECE_DIRECTION(int value) {
            this.value = value;
        }
    }

    public enum PEICE_TEAM{
        WHITE(0),
        BLACK(1);

        private final int value;

        PEICE_TEAM(int value){
            this.value = value;
        }
    }

    public int getDirection()
    {
        return this.team.value;
    }


    public boolean isValidMove(BoardModel model, Position position)
    {
        return !model.isOccupied(position);
    }
}


package chkMVC.chModel.Checkers.Pieces;

import chkMVC.chModel.Checkers.BoardModel;
import chkMVC.chModel.Checkers.Position;

import java.util.ArrayList;
import java.util.List;

public class SerfPiece extends AbstractPiece {

    public SerfPiece(Position position, PEICE_TEAM team) {
        super(position, team);
    }

    @Override
    public List<Position> getValidSimpleMoves(BoardModel board) {
        List<Position> validMoves = new ArrayList<>();
        Position current = getPosition();
        int forwardY = getDirection(); // Get the Y direction based on team

        // Check forward-left
        try {
            Position potentialPos = current.getDeltaPosition(-1, forwardY);
            if (!board.isOccupied(potentialPos)) {
                validMoves.add(potentialPos);
            }
        } catch (IllegalArgumentException e) { /* Off board */ }

        // Check forward-right
        try {
            Position potentialPos = current.getDeltaPosition(1, forwardY);
            if (!board.isOccupied(potentialPos)) {
                validMoves.add(potentialPos);
            }
        } catch (IllegalArgumentException e) { /* Off board */ }

        return validMoves;
    }

    @Override
    public List<Position> getValidJumpMoves(BoardModel board) {
        List<Position> jumpMoves = new ArrayList<>();
        Position current = getPosition();
        int forwardY = getDirection(); // Y direction for moving forward

        // Check jump forward-left
        try {
            Position jumpOverPos = current.getDeltaPosition(-1, forwardY);
            Position landingPos = current.getDeltaPosition(-2, forwardY * 2); // Jump lands 2 steps away
            AbstractPiece pieceToJump = board.getPieceAt(jumpOverPos);
            // Must jump over an OPPONENT piece onto an EMPTY square
            if (pieceToJump != null && pieceToJump.getTeam() != this.getTeam() && !board.isOccupied(landingPos)) {
                jumpMoves.add(landingPos);
            }
        } catch (IllegalArgumentException e) { /* Off board */ }

        // Check jump forward-right
        try {
            Position jumpOverPos = current.getDeltaPosition(1, forwardY);
            Position landingPos = current.getDeltaPosition(2, forwardY * 2);
            AbstractPiece pieceToJump = board.getPieceAt(jumpOverPos);
            if (pieceToJump != null && pieceToJump.getTeam() != this.getTeam() && !board.isOccupied(landingPos)) {
                jumpMoves.add(landingPos);
            }
        } catch (IllegalArgumentException e) { /* Off board */ }

        // TODO: Add multi-jump logic if required (often handled in the Controller/Game Logic)

        return jumpMoves;
    }
}
package chkMVC.chModel.Math;

public class Vector2i {
    public int x, y;

    public Vector2i(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public Vector2i add(Vector2i other) {
        return new Vector2i(this.x + other.x, this.y + other.y);
    }

    public Vector2i subtract(Vector2i other) {
        return new Vector2i(this.x - other.x, this.y - other.y);
    }

    public int dot(Vector2i other) {
        return this.x * other.x + this.y * other.y;
    }

    public int magnitudeSquared() {
        return this.x * this.x + this.y * this.y;
    }

    @Override
    public String toString() {
        return "(" + x + ", " + y + ")";
    }
}
package chkMVC.chView;

import chkMVC.chController.BoardController;
import chkMVC.chModel.Checkers.BoardModel;
import chkMVC.chModel.Checkers.Pieces.AbstractPiece;
import chkMVC.chModel.Checkers.Position;
import chkNetwork.Client.ClientLogic;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

public class BoardView {



    private ClientLogic clientLogic;

    public JFrame frame;
    private JButton announmentButton;
    private BoardModel boardModel;

    BoardController controller;

    ArrayList<JButton> boardButtons;


    BoardView(ClientLogic clientLogic, BoardModel boardModel)
    {
        this.clientLogic = clientLogic;
        this.boardModel = boardModel;
        setupUI();
        addListener();

        frame.setVisible(true);
    }

    JPanel buildBoardGrid(int boardSize)
    {
        JPanel gridPanel = new JPanel();

        gridPanel.setLayout(new GridLayout(boardSize, boardSize));

        for(int i = 0; i < boardSize * boardSize; i++)
        {
            JButton tempButton = new JButton(String.valueOf(i));

            gridPanel.add(tempButton);


            int finalI = i + 1;
            tempButton.addActionListener(e -> {
                clientLogic.sendMessage(String.valueOf(finalI));
            });
        }

        return gridPanel;

    }

    void setupUI()
    {
        frame = new JFrame("Checkers board");
        frame.setSize(new Dimension(400, 400));

        announmentButton = new JButton("Button");
        announmentButton.setPreferredSize(new Dimension(65, 50));

        //windowFrame.add(announmentButton);

        frame.add(buildBoardGrid(boardModel.getHeight()));

    }

    void addListener()
    {
        announmentButton.addActionListener(e -> {
            System.out.println("gui: button pressed.");

            clientLogic.sendMessage("announcing new stuff...");

        });
    }


    public static void main(String[] args) {

        ClientLogic clientLogic1 = new ClientLogic("localhost", 5000);

        BoardModel boardModel = new BoardModel(8);

        BoardView boardWindow = new BoardView(clientLogic1, boardModel);

        boolean connected = clientLogic1.connect("boardTest");

        if (!connected) {
            // Handle connection failure - maybe close the initial window
            System.err.println("Initial connection failed. Exiting.");
            // Ensure GUI resources are cleaned up if connection fails immediately
            SwingUtilities.invokeLater(() -> {
                if (boardWindow.frame != null) {
                    boardWindow.frame.dispose();
                }
            });
            System.exit(1); // Exit with error status
        }
    }
}
package chkNetwork;

public enum CLIENT_REQUEST_CODES {

    // Connection requests
    CONNECT(1000),
    DISCONNECT(1001),
    PING(1002),

    // Game-related requests
    JOIN_GAME(1100),
    LEAVE_GAME(1101),
    START_GAME(1102),

    // Player actions (Checkers specific)
    MOVE_PIECE(1200),      // Move a piece (normal or jump)
    END_TURN(1201),        // End turn manually (if needed)
    FORFEIT_GAME(1202),    // Player gives up
    REQUEST_REMATCH(1203), // Ask for a rematch
    SEND_CHAT_MESSAGE(1204); // Send a chat message

    private final int code;

    CLIENT_REQUEST_CODES(int code) {
        this.code = code;
    }

    public int getCode() {
        return code;
    }
}
package chkNetwork;

import chkNetwork.Server.ServerLogic;

import java.io.IOException;
import java.util.Scanner;

public class ServerRunnerEntrypoint {

    public static void main(String[] args) {
        ServerLogic myServer = new ServerLogic(5000); // Use a specific port

        try {
            myServer.start(); // Start the server in the background

            System.out.println("Server started. Press Enter to stop.");

            // Keep the main application running, wait for user input to stop
            Scanner scanner = new Scanner(System.in);
            scanner.nextLine(); // Wait for Enter key

        } catch (IOException e) {
            System.err.println("Error starting server: " + e.getMessage());
        } finally {
            System.out.println("Requesting server stop...");
            myServer.stop(); // Stop the server gracefully
            System.out.println("Server should now be stopped.");
        }
    }
}
package chkNetwork;

public enum SERVER_RESPONSE_CODES {

    // General success & error responses
    SUCCESS(2000),
    ERROR(2001),
    INVALID_REQUEST(2002),

    // Game state updates
    GAME_STATE_UPDATE(2100),  // Broadcast updated board state
    GAME_START(2101),         // Game officially starts
    GAME_END(2102),           // Game ends
    ROUND_UPDATE(2103),       // Round state update
    PLAYER_JOINED(2104),      // A new player has joined
    PLAYER_LEFT(2105),        // A player left the game

    // Player actions & validation
    MOVE_ACCEPTED(2200),      // Move was valid
    MOVE_REJECTED(2201),      // Move was invalid
    INVALID_TURN(2202),       // Player moved when it's not their turn
    ACTION_NOT_ALLOWED(2203), // Player action not allowed (e.g., wrong piece type)

    // Connection & server issues
    SERVER_ERROR(2300),       // Internal server issue
    CONNECTION_LOST(2301),    // Player lost connection
    RECONNECT_SUCCESS(2302),  // Reconnection successful
    TIMEOUT_WARNING(2303),    // Player timeout warning

    // Messaging & events
    CHAT_MESSAGE(2400),       // Chat message received
    NOTIFICATION(2401);       // General game notifications (e.g., "Your turn!")

    private final int code;

    SERVER_RESPONSE_CODES(int code) {
        this.code = code;
    }

    public int getCode() {
        return code;
    }
}
package chkNetwork.Client;

// Class for things required
public interface ChatView {
    void appendMessage(String message);
    void showErrorMessage(String title, String message);
    void clearInputField();
    void setWindowTitle(String title);
    void closeWindow();
}
package chkNetwork.Client;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

//This class takes the implements the functions required in the view...
public class ChatWindow implements ChatView { // Implement the interface

    private JFrame frame;
    private JTextArea textArea;
    private JTextField textField;
    private JButton sendButton;
    private ClientLogic clientLogic; // Reference to the logic class

    // Constructor takes the logic controller
    public ChatWindow(ClientLogic clientLogic) {
        this.clientLogic = clientLogic;

        this.clientLogic.setView(this);
        createAndShowGUI();
    }

    private void createAndShowGUI() {
        // Use SwingUtilities.invokeLater to ensure GUI creation is on the EDT
        SwingUtilities.invokeLater(() -> {
            frame = new JFrame("Chat Client"); // Initial title
            textArea = new JTextArea();
            textArea.setEditable(false);
            textArea.setLineWrap(true);
            JScrollPane scrollPane = new JScrollPane(textArea);

            textField = new JTextField();
            sendButton = new JButton("Send");

            // Action listener now calls the logic's method
            ActionListener sendAction = e -> handleSendAction();
            textField.addActionListener(sendAction);
            sendButton.addActionListener(sendAction);

            frame.setLayout(new BorderLayout());
            frame.add(scrollPane, BorderLayout.CENTER);
            JPanel bottomPanel = new JPanel();
            bottomPanel.setLayout(new BorderLayout());
            bottomPanel.add(textField, BorderLayout.CENTER);
            bottomPanel.add(sendButton, BorderLayout.EAST);
            frame.add(bottomPanel, BorderLayout.SOUTH);

            frame.setSize(400, 300);
            // Change default close operation to notify logic
            frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
            frame.addWindowListener(new WindowAdapter() {
                @Override
                public void windowClosing(WindowEvent e) {
                    // Tell the logic to disconnect before closing
                    clientLogic.disconnect();
                    frame.dispose(); // Close the window
                    System.exit(0); // Exit application if this is the main window
                }
            });

            frame.setVisible(true);
            textField.requestFocusInWindow(); // Set focus to input field
        });
    }

    // Handles sending text from the input field
    private void handleSendAction() {
        String message = textField.getText();
        if (!message.trim().isEmpty()) {
            // Check if it's a command (e.g., starts with '/') or plain chat
            if (message.startsWith("/")) {
                // Basic command parsing (needs improvement)
                // Example: /move A1 B2 -> sendCommand(MOVE, ["A1", "B2"])
                // This parsing logic might live here or be passed to clientLogic
                System.out.println("Command detected (implement parsing): " + message);
                // clientLogic.parseAndSendCommand(message); // You'd need this method in CheckersClient
                appendMessage("Client: Command handling not fully implemented yet."); // Feedback
                textField.setText("");
            } else {
                // Send as regular chat message via the logic class
                clientLogic.sendMessage(message);
                // Logic class now calls clearInputField via the interface upon success
            }
        }
    }

    // --- Implementation of ChatView Interface ---

    //Push new message onto stack.
    @Override
    public void appendMessage(String message) {
        // Ensure updates are on the EDT (already handled if called via SwingUtilities.invokeLater)
        if (SwingUtilities.isEventDispatchThread()) {
            textArea.append(message + "\n");
            // Auto-scroll to bottom
            textArea.setCaretPosition(textArea.getDocument().getLength());
        } else {
            SwingUtilities.invokeLater(() -> appendMessage(message));
        }
    }

    @Override
    public void showErrorMessage(String title, String message) {
        if (SwingUtilities.isEventDispatchThread()) {
            JOptionPane.showMessageDialog(frame, message, title, JOptionPane.ERROR_MESSAGE);
        } else {
            SwingUtilities.invokeLater(() -> showErrorMessage(title, message));
        }
    }

    @Override
    public void clearInputField() {
        if (SwingUtilities.isEventDispatchThread()) {
            textField.setText("");
        } else {
            SwingUtilities.invokeLater(this::clearInputField);
        }
    }

    @Override
    public void setWindowTitle(String title) {
        if (SwingUtilities.isEventDispatchThread()) {
            frame.setTitle(title);
        } else {
            SwingUtilities.invokeLater(() -> setWindowTitle(title));
        }
    }

    @Override
    public void closeWindow() {
        if (SwingUtilities.isEventDispatchThread()) {
            frame.dispose();
        } else {
            SwingUtilities.invokeLater(this::closeWindow);
        }
    }


    // --- Main method to launch the application ---
    public static void main(String[] args) {
        // 1. Get username
        String username = JOptionPane.showInputDialog("Enter your username:");
        if (username == null || username.trim().isEmpty()) {
            System.out.println("Username cancelled or empty. Exiting.");
            System.exit(0);
        }

        // 2. Create the logic component
        // Ideally, get host/port from config or args
        ClientLogic clientLogic = new ClientLogic("localhost", 5000);

        // 3. Create the GUI component (View) and link it to the logic
        // The ChatWindow constructor now calls clientLogic.setView(this)
        ChatWindow chatWindow = new ChatWindow(clientLogic);

        // 4. Attempt to connect (after GUI is initialized and linked)
        boolean connected = clientLogic.connect(username);

        if (!connected) {
            // Handle connection failure - maybe close the initial window
            System.err.println("Initial connection failed. Exiting.");
            // Ensure GUI resources are cleaned up if connection fails immediately
            SwingUtilities.invokeLater(() -> {
                if (chatWindow.frame != null) {
                    chatWindow.frame.dispose();
                }
            });
            System.exit(1); // Exit with error status
        }

        // Application is now running, driven by events and the listener thread...
        System.out.println("Application setup complete. GUI visible. Listening for messages.");
    }
}
package chkNetwork.Client;

import chkNetwork.CLIENT_REQUEST_CODES;

import java.io.*;
import java.net.*;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

public class ClientLogic {

    private final String host;
    private final int port;
    private String username;
    private Socket socket;
    private PrintWriter out;
    private BufferedReader in;
    private ChatView view; // Reference to the GUI
    private final AtomicBoolean isRunning = new AtomicBoolean(false);
    private final ExecutorService networkExecutor = Executors.newSingleThreadExecutor(); // For listener thread

    public ClientLogic(String host, int port) {
        this.host = host;
        this.port = port;
    }

    // Setter for the View (GUI)
    public void setView(ChatView view) {
        this.view = view;
    }

    // Attempt to connect to the server
    public boolean connect(String username) {
        if (isRunning.get()) {
            System.err.println("Already connected or connecting.");
            return true; // Or false, depending on desired behavior
        }
        this.username = username;
        if (this.username == null || this.username.trim().isEmpty()) {
            if (view != null) view.showErrorMessage("Login Error", "Username cannot be empty.");
            return false;
        }

        try {
            socket = new Socket(host, port);
            out = new PrintWriter(socket.getOutputStream(), true);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            // Send username immediately
            out.println(this.username);

            // Start the listener thread using an ExecutorService
            isRunning.set(true);
            networkExecutor.submit(this::listenToServer); // Pass method reference

            if (view != null) {
                view.setWindowTitle(this.username + "'s Chat Client - Connected");
            }
            System.out.println("Connected successfully as " + this.username);
            return true;

        } catch (UnknownHostException e) {
            if (view != null) view.showErrorMessage("Connection Error", "Unknown host: " + host);
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            if (view != null)
                view.showErrorMessage("Connection Error", "Couldn't connect to server: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    // Background task to listen for messages from the server
    private void listenToServer() {
        try {
            String messageFromServer;
            while (isRunning.get() && (messageFromServer = in.readLine()) != null) {
                // Process different types of messages from server
                // For now, just display everything
                if (view != null) {
                    // Ensure GUI updates happen on the Event Dispatch Thread
                    final String finalMessage = messageFromServer; // Need final variable for lambda
                    javax.swing.SwingUtilities.invokeLater(() -> view.appendMessage(finalMessage));
                } else {
                    System.out.println("Received (no view): " + messageFromServer);
                }

                // Example: Check for specific server messages
                if ("ERROR: Username".equals(messageFromServer.substring(0, Math.min(messageFromServer.length(), 16)))) {
                    String finalMessageFromServer = messageFromServer;
                    javax.swing.SwingUtilities.invokeLater(() -> {
                        view.showErrorMessage("Login Failed", finalMessageFromServer);
                        disconnect(); // Disconnect if username is invalid/taken
                        view.closeWindow(); // Maybe close the window too
                    });
                }
            }
        } catch (SocketException e) {
            if (isRunning.get()) { // Only show error if we didn't intentionally disconnect
                System.err.println("SocketException in listener: " + e.getMessage() + " (Likely server disconnected)");
                if (view != null)
                    javax.swing.SwingUtilities.invokeLater(() -> view.showErrorMessage("Connection Lost", "Lost connection to the server."));
            } else {
                System.out.println("Listener stopped due to intended disconnect.");
            }
        } catch (IOException e) {
            if (isRunning.get()) {
                System.err.println("IOException in listener: " + e.getMessage());
                e.printStackTrace();
                if (view != null)
                    javax.swing.SwingUtilities.invokeLater(() -> view.showErrorMessage("Network Error", "Error reading from server: " + e.getMessage()));
            }
        } finally {
            // Ensure cleanup happens even if loop exits unexpectedly
            disconnect(); // Clean up resources if listener thread ends
            System.out.println("Server listener thread finished.");
        }
    }

    // Send a standard chat message
    public void sendMessage(String message) {
        if (out != null && isRunning.get() && message != null && !message.trim().isEmpty()) {
            out.println(message);
            if (view != null) {
                javax.swing.SwingUtilities.invokeLater(() -> view.clearInputField());
            }
        } else if (!isRunning.get()) {
            if (view != null)
                javax.swing.SwingUtilities.invokeLater(() -> view.showErrorMessage("Send Error", "Not connected to the server."));
        }
    }

    // Send a formatted command (implementation based on your previous request)
    public void sendCommand(CLIENT_REQUEST_CODES request, List<String> args) {
        if (out != null && isRunning.get()) {
            StringBuilder commandString = new StringBuilder();
            commandString.append("/").append(request.name()); // Assuming commands start with '/'
            if (args != null && !args.isEmpty()) {
                for (String arg : args) {
                    // Basic argument joining, might need better escaping if args can contain spaces
                    commandString.append(" ").append(arg);
                }
            }
            System.out.println("Sending command: " + commandString); // Log command
            out.println(commandString.toString());
        } else {
            System.err.println("Cannot send command - not connected.");
            if (view != null)
                javax.swing.SwingUtilities.invokeLater(() -> view.showErrorMessage("Command Error", "Not connected, cannot send command."));
        }
    }


    // Disconnect from the server and clean up resources
    public void disconnect() {
        if (!isRunning.compareAndSet(true, false)) {
            return; // Already disconnected or not connected
        }
        System.out.println("Disconnecting...");

        networkExecutor.shutdown(); // Signal listener thread to stop accepting tasks

        try {
            if (socket != null && !socket.isClosed()) {
                socket.close(); // This will cause readLine() in listener to throw SocketException
            }
        } catch (IOException e) {
            System.err.println("Error closing socket: " + e.getMessage());
        } finally {
            // Nullify resources
            in = null;
            out = null;
            socket = null;
            if (view != null) {
                javax.swing.SwingUtilities.invokeLater(() -> view.setWindowTitle(this.username + "'s Chat Client - Disconnected"));
            }
            System.out.println("Disconnected.");
        }
        try {
            // Wait for the listener thread to terminate
            if (!networkExecutor.awaitTermination(2, TimeUnit.SECONDS)) {
                networkExecutor.shutdownNow(); // Force stop if it doesn't finish
            }
        } catch (InterruptedException e) {
            networkExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
package chkNetwork.Client;

/***
 * This Class is like super duper important for server things (not really)...
 *
 * it just sends things as simple events.
 * This is going to be the class that
 * kind of helps with that stuff...
 */
public class clientRequest {

    public clientRequest()
    {

    }




}
package chkNetwork.Server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.net.SocketException;
import java.util.Set;

class ClientHandler implements Runnable { // Implement Runnable

    private final Socket socket;
    private final ServerLogic serverInstance; // Reference to the parent server
    private PrintWriter out;
    private BufferedReader in;
    private volatile String username; // Make username volatile as it's set after thread start
    private volatile boolean clientRunning = true;

    public ClientHandler(Socket socket, ServerLogic serverInstance) {
        this.socket = socket;
        this.serverInstance = serverInstance; // Store the server instance
    }

    public String getUsername() {
        return username;
    }

    // Method to send a message to this specific client
    public void sendResponse(String message) {
        if (out != null && clientRunning) { // Check if output stream is ready and running
            out.println(message);
        }
    }

    // Send the list of currently connected users to this client
    public void sendUserList() {
        Set<String> userNames = serverInstance.getConnectedUsernames();
        // Fix the user list string!
        StringBuilder clientsList = new StringBuilder("Connected users (");
        clientsList.append(userNames.size()).append("): "); // Use the actual size
        clientsList.append(String.join(" ", userNames));
        sendResponse(clientsList.toString());
    }


    @Override
    public void run() {
        try {
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new PrintWriter(socket.getOutputStream(), true);

            // 1. Get username
            // Add a timeout for username entry?
            String receivedUsername = in.readLine();
            if (receivedUsername == null) {
                System.out.println("Client disconnected before sending username.");
                return; // Exit run method
            }
            this.username = receivedUsername.trim(); // Set the username for this handler


            serverInstance.registerClient(this, this.username);
            // If registration fails (e.g., duplicate name), registerClient will close the connection


            // 3. Listen for messages from this client
            String message;
            while (clientRunning && (message = in.readLine()) != null) {
                System.out.println(username + ": " + message); // Log server side

                // Process potential commands or broadcast chat
                // TODO: Add command parsing logic here (e.g., "/move", "/resign")
                if (message.startsWith("/")) {
                    handleCommand(message);
                } else {
                    // Broadcast chat message
                    serverInstance.broadcastMessage(username + ": " + message, this);
                }
            }

        } catch (SocketException e) {
            if (!clientRunning) {
                System.out.println("Client socket closed for " + (username != null ? username : "unknown user") + " as requested.");
            } else {
                System.err.println("SocketException for " + (username != null ? username : "unknown user") + ": " + e.getMessage() + " (Likely client disconnected abruptly)");
            }
        } catch (IOException e) {
            if (clientRunning) { // Avoid error message if we closed intentionally
                System.err.println("IOException for client " + (username != null ? username : "unknown user") + ": " + e.getMessage());
                e.printStackTrace();
            }
        } finally {
            closeConnection(null); // Ensure cleanup happens
        }
        System.out.println("Client handler finished for: " + (username != null ? username : "unknown user"));
    }

    private void handleCommand(String command) {
        // Basic command handling placeholder
        System.out.println("Received command from " + username + ": " + command);
        sendResponse("SERVER: Command '" + command + "' received (not implemented yet).");
        // Example: if (command.equalsIgnoreCase("/ready")) { serverInstance.markPlayerReady(this); }
    }

    // Gracefully close connection for this client
    public void closeConnection(String reason) {
        if (!clientRunning) return; // Already closing/closed
        clientRunning = false; // Signal loops to stop

        System.out.println("Closing connection for " + (username != null ? username : "unknown user") + (reason != null ? ". Reason: " + reason : ""));

        // Unregister *before* closing socket if possible
        serverInstance.unregisterClient(this);

        try {
            if (socket != null && !socket.isClosed()) {
                // Maybe send a final "goodbye" message before closing?
                // sendMessage("SERVER: Disconnecting. " + (reason != null ? reason : ""));
                socket.close(); // This also closes associated streams (in/out)
            }
        } catch (IOException e) {
            System.err.println("Error closing socket for " + (username != null ? username : "unknown user") + ": " + e.getMessage());
        } finally {
            // Nullify resources
            in = null;
            out = null;
        }
    }
}

package chkNetwork.Server;

import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ServerLogic implements Runnable { // Implement Runnable for the main accept loop

    private final int port;
    private ServerSocket serverSocket;
    private volatile boolean isRunning = false; // Flag to control the main loop
    private Thread serverThread; // Thread running the accept loop
    private final ExecutorService clientExecutor; // To manage client handler threads

    // Instance fields instead of static
    private final Set<ClientHandler> clientHandlers = Collections.synchronizedSet(new HashSet<>());
    private final Map<String, ClientHandler> clients = Collections.synchronizedMap(new HashMap<>());

    // Game-specific logic (still needs proper integration)
    private ClientHandler host = null;
    private ClientHandler white = null;
    private ClientHandler black = null;
    private ServerView view;

    // Setter for the View (GUI)
    public void setView(ServerView view) {
        this.view = view;
    }

    public ServerLogic(int port) {
        this.port = port;
        // Use a thread pool for client handlers for better resource management
        this.clientExecutor = Executors.newCachedThreadPool();
    }


    public void start() throws IOException {
        if (isRunning) {
            System.out.println("Server is already running on port " + port);
            return;
        }
        System.out.println("Starting Checkers server on port " + port + "...");
        serverSocket = new ServerSocket(port);
        isRunning = true;
        // Start the main accept loop in its own thread
        serverThread = new Thread(this, "CheckersServer-AcceptThread");
        serverThread.start();
        System.out.println("Server started successfully.");
    }

    public void stop() {
        if (!isRunning) {
            System.out.println("Server is not running.");
            return;
        }
        System.out.println("Stopping Checkers server...");
        isRunning = false; // Signal the accept loop to stop

        // Close the server socket - this will interrupt the accept() call
        try {
            if (serverSocket != null && !serverSocket.isClosed()) {
                serverSocket.close(); // Causes SocketException in run() method's accept()
            }
        } catch (IOException e) {
            System.err.println("Error closing server socket: " + e.getMessage());
        }

        // Gracefully shut down client threads
        clientExecutor.shutdown(); // Disable new tasks from being submitted
        try {
            // Wait a while for existing tasks to terminate
            if (!clientExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                clientExecutor.shutdownNow(); // Cancel currently executing tasks
                // Wait a while for tasks to respond to being cancelled
                if (!clientExecutor.awaitTermination(5, TimeUnit.SECONDS))
                    System.err.println("Client handler pool did not terminate");
            }
        } catch (InterruptedException ie) {
            // (Re-)Cancel if current thread also interrupted
            clientExecutor.shutdownNow();
            // Preserve interrupt status
            Thread.currentThread().interrupt();
        }

        // Explicitly close remaining client sockets (redundant if shutdownNow worked)
        // Use a copy to avoid ConcurrentModificationException while iterating and removing
        synchronized (clientHandlers) {
            Set<ClientHandler> handlersCopy = new HashSet<>(clientHandlers);
            for(ClientHandler handler : handlersCopy) {
                handler.closeConnection("Server shutting down");
            }
        }
        clientHandlers.clear(); // Should be empty now
        clients.clear();

        // Wait for the server thread to die
        try {
            if (serverThread != null && serverThread.isAlive()) {
                serverThread.join(1000); // Wait max 1 sec for the thread to finish
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.err.println("Interrupted while waiting for server thread to stop.");
        }

        System.out.println("Server stopped.");
    }

    @Override
    public void run() {
        System.out.println("Server accept loop started. Listening for connections...");
        while (isRunning) {
            try {
                Socket clientSocket = serverSocket.accept(); // Blocking call
                System.out.println("Connection received from " + clientSocket.getRemoteSocketAddress());
                // Create and start a handler for the new client
                ClientHandler handler = new ClientHandler(clientSocket, this); // Pass 'this' server instance
                clientExecutor.submit(handler); // Use executor service
                // handler.start(); // Old way: starting thread directly
            } catch (SocketException e) {
                // Expected when serverSocket.close() is called in stop()
                if (!isRunning) {
                    System.out.println("Server socket closed, accept loop terminating.");
                } else {
                    System.err.println("SocketException in accept loop: " + e.getMessage());
                    // Consider whether to try and recover or shut down
                    // stop(); // Option: Stop server on unexpected socket errors
                }
            } catch (IOException e) {
                if (isRunning) {
                    System.err.println("IOException in accept loop: " + e.getMessage());
                    e.printStackTrace();
                    // Consider stopping if the error is critical
                }
            }
        }
        System.out.println("Server accept loop finished.");
    }


    void registerClient(ClientHandler handler, String username) {
        if (username == null || username.trim().isEmpty()) {
            System.err.println("Attempt to register client with null or empty username.");
            handler.closeConnection("Invalid username provided.");
            return;
        }
        if (clients.containsKey(username)) {
            System.err.println("Username '" + username + "' is already taken.");
            handler.sendResponse("ERROR: Username '" + username + "' is already taken. Please reconnect with a different name.");
            handler.closeConnection("Username taken");
            return;
        }

        synchronized (clients) {
            clients.put(username, handler);
        }
        synchronized (clientHandlers) {
            clientHandlers.add(handler);
        }

        // Assign roles (basic example, needs more logic)
        assignRoles(handler);

        System.out.println(username + " successfully registered.");

        // Send current user list to the new client
        handler.sendUserList();

        // Notify others
        broadcastMessage(username + " has joined the chat!", handler); // Exclude sender
    }

    void unregisterClient(ClientHandler handler) {
        String username = handler.getUsername(); // Get username before removing
        boolean removed = false;
        synchronized (clientHandlers) {
            removed = clientHandlers.remove(handler);
        }
        if (username != null) {
            synchronized (clients) {
                clients.remove(username);
            }
            // Reset roles if the leaving client held one
            if (handler == host) host = null;
            if (handler == white) white = null;
            if (handler == black) black = null;
            // Could re-assign roles here if needed

            System.out.println(username + " unregistered.");
            if (removed) { // Only broadcast leave if they were fully registered
                broadcastMessage(username + " has left the chat.", null); // Send to everyone
            }
        } else {
            System.out.println("An unregistered client disconnected.");
        }


    }

    void broadcastMessage(String message, ClientHandler sender) {
        // Use a snapshot to avoid issues if clientHandlers changes during iteration
        Set<ClientHandler> handlersSnapshot;
        synchronized (clientHandlers) {
            handlersSnapshot = new HashSet<>(clientHandlers);
        }

        System.out.println("Broadcasting: " + message + (sender != null ? " (from " + sender.getUsername() + ")" : " (from Server)"));
        view.appendMessage(message);

        for (ClientHandler handler : handlersSnapshot) {
            if (handler != sender) {
                handler.sendResponse(message);

            }
        }
    }

    private synchronized void assignRoles(ClientHandler newHandler) {
        // Simple first-come, first-served assignment
        if (host == null) {
            host = newHandler;
            newHandler.sendResponse("SERVER: You are the host.");
            System.out.println(newHandler.getUsername() + " assigned as host.");
        }

        if (white == null) {
            white = newHandler;
            newHandler.sendResponse("SERVER: You are playing as White.");
            System.out.println(newHandler.getUsername() + " assigned as White.");
        } else if (black == null) {
            black = newHandler;
            newHandler.sendResponse("SERVER: You are playing as Black.");
            System.out.println(newHandler.getUsername() + " assigned as Black.");
        } else {
            newHandler.sendResponse("SERVER: The game is full, you are spectating.");
            System.out.println(newHandler.getUsername() + " is spectating.");
        }
    }

    public int getPort() {
        return port;
    }

    public boolean isRunning() {
        return isRunning;
    }

    public Set<String> getConnectedUsernames() {
        synchronized (clients) {
            return new HashSet<>(clients.keySet());
        }
    }

    // --- Main method (for standalone execution) ---
    public static void main(String[] args) {
        final int DEFAULT_PORT = 5000;

        ServerLogic server = new ServerLogic(DEFAULT_PORT);

        ServerWindow window = new ServerWindow(server);

        try {
            server.start();

            // Keep the main thread alive, or add shutdown hooks
            // Example: Add a shutdown hook to stop the server gracefully on Ctrl+C
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                System.out.println("Shutdown hook triggered. Stopping server...");
                server.stop();
            }));


            // Keep main alive indefinitely (or until shutdown hook)
            // server.serverThread.join(); // Alternatively, wait for the server thread itself


        } catch (IOException e) {
            System.err.println("Failed to start server on port " + DEFAULT_PORT + ": " + e.getMessage());
            e.printStackTrace();
        }




        // Note: If start() throws an exception, the shutdown hook won't have anything to stop.
    }

}
package chkNetwork.Server;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// Enum for different types of messages the server might send
enum ResponseType {
    JOIN_NOTIFICATION,  // "User X has joined..."
    LEAVE_NOTIFICATION, // "User Y has left..."
    BROADCAST_MESSAGE,  // "User Z: some message"
    USER_LIST,          // "Connected users: A, B, C"
    SERVER_MESSAGE,     // General server info/error
    UNKNOWN             // If parsing fails
}

// The class to represent a structured server response
class ServerResponse {
    private final ResponseType type;
    private final String sender;      // For BROADCAST, JOIN, LEAVE
    private final String payload;     // Message content for BROADCAST, SERVER_MESSAGE
    private final List<String> users; // For USER_LIST
    private final String rawMessage;  // Keep the original for debugging

    // Private constructor, use static factory method 'parse'
    private ServerResponse(ResponseType type, String sender, String payload, List<String> users, String rawMessage) {
        this.type = type;
        this.sender = sender;
        this.payload = payload;
        this.users = users;
        this.rawMessage = rawMessage;
    }

    // --- Getters ---
    public ResponseType getType() { return type; }
    public String getSender() { return sender; }
    public String getPayload() { return payload; }
    public List<String> getUsers() { return users; }
    public String getRawMessage() { return rawMessage; }


    // --- Static Parsing Logic ---
    // Define patterns for expected message formats
    private static final Pattern JOIN_PATTERN = Pattern.compile("^(\\w+) has joined the chat!?$");
    private static final Pattern LEAVE_PATTERN = Pattern.compile("^(\\w+) has left the chat\\.?$");
    private static final Pattern BROADCAST_PATTERN = Pattern.compile("^(\\w+):\\s*(.*)$");
    private static final Pattern USER_LIST_PATTERN = Pattern.compile("^Connected users:\\s*(.*)$");


    /**
     * Parses a raw string message from the server into a ServerResponse object.
     * This is where you adapt the logic to your server's specific output format.
     */
    public static ServerResponse parse(String rawMessage) {
        if (rawMessage == null) {
            return new ServerResponse(ResponseType.UNKNOWN, null, null, null, null);
        }

        Matcher matcher;

        matcher = JOIN_PATTERN.matcher(rawMessage);
        if (matcher.matches()) {
            String user = matcher.group(1);
            return new ServerResponse(ResponseType.JOIN_NOTIFICATION, user, null, null, rawMessage);
        }

        matcher = LEAVE_PATTERN.matcher(rawMessage);
        if (matcher.matches()) {
            String user = matcher.group(1);
            return new ServerResponse(ResponseType.LEAVE_NOTIFICATION, user, null, null, rawMessage);
        }

        matcher = BROADCAST_PATTERN.matcher(rawMessage);
        if (matcher.matches()) {
            String sender = matcher.group(1);
            String message = matcher.group(2);
            return new ServerResponse(ResponseType.BROADCAST_MESSAGE, sender, message, null, rawMessage);
        }

        matcher = USER_LIST_PATTERN.matcher(rawMessage);
        if (matcher.matches()) {
            String userListStr = matcher.group(1);
            List<String> users = Arrays.asList(userListStr.split(",\\s*")); // Split by comma and optional space
            // Handle potential empty list if the string was just "Connected users: "
            if (users.size() == 1 && users.get(0).isEmpty()) {
                users = List.of(); // Represent as empty list
            }
            return new ServerResponse(ResponseType.USER_LIST, null, null, users, rawMessage);
        }


        // If none of the specific patterns match, treat as a generic server message or unknown
        // You might refine this based on other expected server messages
        System.err.println("WARN: Could not parse server message: " + rawMessage);
        return new ServerResponse(ResponseType.UNKNOWN, null, rawMessage, null, rawMessage); // Or SERVER_MESSAGE?
    }

    @Override
    public String toString() {
        return "ServerResponse{" +
                "type=" + type +
                ", sender='" + sender + '\'' +
                ", payload='" + payload + '\'' +
                ", users=" + users +
                ", raw='" + rawMessage.substring(0, Math.min(rawMessage.length(), 50)) + "...'" + // Avoid huge raw output
                '}';
    }

    // Optional: Implement equals/hashCode if needed for comparisons
}
package chkNetwork.Server;

import java.util.ArrayList;

//Idk this is important...
public interface ServerView {
    void appendMessage(String message);
    void showErrorMessage(String title, String message);
    void setWindowTitle(String title);
    void updateUserList(ArrayList<String> userlist);
}
package chkNetwork.Server;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;

//This class takes the implements the functions required in the view...
public class ServerWindow implements ServerView { // Implement the interface

    private JFrame frame;
    private JTextArea textArea;
    private JList<String> activeUsers;

    private final ServerLogic serverLogic; // Reference to the logic class

    // Constructor takes the logic controller
    public ServerWindow(ServerLogic serverLogic) {
        this.serverLogic = serverLogic;

        this.serverLogic.setView(this);

        createAndShowGUI();
    }

    private void createAndShowGUI() {
        // Use SwingUtilities.invokeLater to ensure GUI creation is on the EDT
        SwingUtilities.invokeLater(() -> {
            frame = new JFrame("Server Client Log"); // Initial title
            textArea = new JTextArea();
            textArea.setEditable(false);
            textArea.setLineWrap(true);
            JScrollPane scrollPane = new JScrollPane(textArea);



            frame.setLayout(new BorderLayout());
            frame.add(scrollPane, BorderLayout.CENTER);
            JPanel bottomPanel = new JPanel();
            bottomPanel.setLayout(new BorderLayout());
            frame.add(bottomPanel, BorderLayout.SOUTH);

            frame.setSize(400, 300);
            // Change default close operation to notify logic
            frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
            frame.addWindowListener(new WindowAdapter() {
                @Override
                public void windowClosing(WindowEvent e) {
                    serverLogic.stop();
                    frame.dispose(); // Close the window
                    System.exit(0); // Exit application if this is the main window
                }
            });


            JPanel rightPanel = new JPanel();

            this.activeUsers = new JList<>();

            rightPanel.add(activeUsers);

            frame.add(rightPanel, BorderLayout.EAST);



            frame.setVisible(true);
        });
    }

    // --- Implementation of ChatView Interface ---

    //Push new message onto stack.
    @Override
    public void appendMessage(String message) {
        System.out.println("Appending...... " + message);
        // Ensure updates are on the EDT (already handled if called via SwingUtilities.invokeLater)
        if (SwingUtilities.isEventDispatchThread()) {
            textArea.append(message + "\n");
            // Auto-scroll to bottom
            textArea.setCaretPosition(textArea.getDocument().getLength());
        } else {
            SwingUtilities.invokeLater(() -> appendMessage(message));
        }

        System.out.println("Should have been updated?");
    }

    @Override
    public void showErrorMessage(String title, String message) {
        if (SwingUtilities.isEventDispatchThread()) {
            JOptionPane.showMessageDialog(frame, message, title, JOptionPane.ERROR_MESSAGE);
        } else {
            SwingUtilities.invokeLater(() -> showErrorMessage(title, message));
        }
    }

    @Override
    public void setWindowTitle(String title) {
        if (SwingUtilities.isEventDispatchThread()) {
            frame.setTitle(title);
        } else {
            SwingUtilities.invokeLater(() -> setWindowTitle(title));
        }
    }

    @Override
    public void updateUserList(ArrayList<String> userlist) {

        this.activeUsers.removeAll();

        for(String user: userlist)
        {
            this.activeUsers.add(new JButton(user));
        }

    }
}
package ModelTest;

import chkGameUtil.BoardHelperSingleton;
import chkMVC.chModel.Checkers.BoardModel;
import chkMVC.chModel.Checkers.Pieces.AbstractPiece;
import chkMVC.chModel.Checkers.Position;
import chkMVC.chModel.Checkers.Pieces.SerfPiece;
import chkMVC.chModel.Math.Vector2i;
import org.junit.jupiter.api.*;

import java.util.List; // Use List instead of ArrayList for return type consistency

import static org.junit.jupiter.api.Assertions.*; // Use static imports for brevity

public class BoardModelTest {

    private static BoardModel gameBoardModel; // Hold the board model instance

    @BeforeAll
    static void initBoard() {
        BoardHelperSingleton.initialize(8);
        gameBoardModel = BoardHelperSingleton.getInstance().getBoard(); // Get the board instance
        System.out.println("Board Initialized for Tests.");
    }

    @AfterEach
    void clearBoardAfterTest() {
        gameBoardModel.clearBoard(); // Clear board after each test
        assertEquals(0, gameBoardModel.getNumberOfPieces(), "Board should be empty after clearing.");
        System.out.println("--- Test Finished, Board Cleared ---");
    }

    @Test
    void testBoardInitProper() {
        System.out.println("Testing Board Initialization...");
        assertNotNull(gameBoardModel, "BoardModel instance should not be null.");
        assertEquals(8, BoardHelperSingleton.getInstance().getBoardHeight(), "Game board height did not initialize to the expected size.");
        assertEquals(8, BoardHelperSingleton.getInstance().getBoardWidth(), "Game board width did not initialize to the expected size.");
        assertEquals(0, gameBoardModel.getNumberOfPieces(), "Newly initialized board should have 0 pieces.");
        System.out.println("Board Initialization Test Passed.");
    }

    @Test
    void testPlaceAndGetPiece() {
        System.out.println("Testing Piece Placement and Retrieval...");
        Position pos = gameBoardModel.createPosition(3, 3);
        SerfPiece piece = new SerfPiece(pos, AbstractPiece.PEICE_TEAM.WHITE);

        // Place the piece
        assertDoesNotThrow(() -> gameBoardModel.placePiece(piece), "Placing a piece on an empty square should not throw.");
        assertEquals(1, gameBoardModel.getNumberOfPieces(), "Board should have 1 piece after placement.");
        assertTrue(gameBoardModel.isOccupied(pos), "Position should be occupied after placement.");

        // Retrieve the piece
        AbstractPiece retrievedPiece = gameBoardModel.getPieceAt(pos);
        assertNotNull(retrievedPiece, "Should be able to retrieve the placed piece.");
        assertSame(piece, retrievedPiece, "Retrieved piece should be the same instance as the placed piece.");
        assertEquals(piece.getId(), retrievedPiece.getId(), "Retrieved piece ID should match.");
        assertEquals(pos, retrievedPiece.getPosition(), "Retrieved piece position should match.");

        System.out.println("Piece Placement and Retrieval Test Passed.");
        gameBoardModel.printBoard(); // Optional: print board state
    }


    @Test
    void testAddPieceToOccupiedSpot() {
        Vector2i boardSize = gameBoardModel.getSize();
        System.out.println("Testing Adding Piece to Occupied Spot...");
        Position position = gameBoardModel.createPosition(3, 3);

        // Place the first piece
        SerfPiece piece1 = new SerfPiece(position, AbstractPiece.PEICE_TEAM.WHITE);
        gameBoardModel.placePiece(piece1);
        assertTrue(gameBoardModel.isOccupied(position), "The spot should be occupied after adding the first piece.");
        assertEquals(1, gameBoardModel.getNumberOfPieces(), "Should be 1 piece on board.");

        // Try to place a second piece at the same spot
        SerfPiece piece2 = new SerfPiece(position, AbstractPiece.PEICE_TEAM.BLACK); // Different team, still invalid

        // Expect an IllegalStateException
        IllegalStateException thrown = assertThrows(
                IllegalStateException.class,
                () -> gameBoardModel.placePiece(piece2), // Use placePiece, not addPiece
                "Expected placePiece() to throw an IllegalStateException when adding to an occupied spot."
        );

        // Check the exception message (optional, but good practice)
        // The message includes the piece occupying the spot, so we check the start
        assertTrue(thrown.getMessage().startsWith("Cannot place piece at " + position),
                "Exception message should indicate the occupied position. Got: " + thrown.getMessage());

        assertEquals(1, gameBoardModel.getNumberOfPieces(), "Number of pieces should remain 1 after failed placement.");

        System.out.println("Adding to Occupied Spot Test Passed.");
        gameBoardModel.printBoard(); // Optional: print board state
    }

    @Test
    void testGettingValidSimpleMovesEmptyBoard() {
        System.out.println("Testing Valid Simple Moves on Empty Board...");

        Position startPos = gameBoardModel.createPosition(3, 3); // C3
        SerfPiece myPiece = new SerfPiece(startPos, AbstractPiece.PEICE_TEAM.WHITE);
        gameBoardModel.placePiece(myPiece);

        // White moves forward (Y increases)
        Position expectedPos1 = gameBoardModel.createPosition(2, 4); // B4 (Forward-Left)
        Position expectedPos2 = gameBoardModel.createPosition(4, 4); // D4 (Forward-Right)

        // Use getValidSimpleMoves
        List<Position> validMoveSpots = myPiece.getValidSimpleMoves(gameBoardModel);

        assertNotNull(validMoveSpots, "Valid moves list should not be null.");
        assertEquals(2, validMoveSpots.size(), "White piece at C3 on empty board should have 2 simple moves.");

        // Check if both expected positions are present (order might vary, so use contains)
        assertTrue(validMoveSpots.contains(expectedPos1), "Valid moves should include B4.");
        assertTrue(validMoveSpots.contains(expectedPos2), "Valid moves should include D4.");

        System.out.println("Valid Simple Moves (Empty Board) Test Passed.");
        gameBoardModel.printBoard();
    }


    @Test
    void testGetValidSimpleMoveBlockedByOwnPiece() {
        System.out.println("Testing Valid Simple Moves Blocked by Own Piece...");
        Position startPos = gameBoardModel.createPosition(3, 3); // C3 (White)
        Position blockingPos = gameBoardModel.createPosition(2, 4); // B4 (White) - Blocks forward-left

        SerfPiece protagPiece = new SerfPiece(startPos, AbstractPiece.PEICE_TEAM.WHITE);
        SerfPiece blockingPiece = new SerfPiece(blockingPos, AbstractPiece.PEICE_TEAM.WHITE); // Same team

        gameBoardModel.placePiece(protagPiece);
        gameBoardModel.placePiece(blockingPiece);

        Position expectedPos = gameBoardModel.createPosition(4, 4); // D4 (Forward-Right) - Should still be valid

        // Use getValidSimpleMoves
        List<Position> validMoveSpots = protagPiece.getValidSimpleMoves(gameBoardModel);

        assertNotNull(validMoveSpots, "Valid moves list should not be null.");
        assertEquals(1, validMoveSpots.size(), "Should only have ONE available simple move when one path is blocked by own piece.");
        assertEquals(expectedPos, validMoveSpots.get(0), "The only valid move should be D4.");

        System.out.println("Valid Simple Moves (Blocked by Own Piece) Test Passed.");
        gameBoardModel.printBoard();
    }

    @Test
    void testGetValidSimpleMoveBlockedByOpponentPiece() {
        System.out.println("Testing Valid Simple Moves Blocked by Opponent Piece...");
        Position startPos = gameBoardModel.createPosition(3, 3); // C3 (White)
        Position blockingPos = gameBoardModel.createPosition(4, 4); // D4 (Black) - Blocks forward-right

        SerfPiece protagPiece = new SerfPiece(startPos, AbstractPiece.PEICE_TEAM.WHITE);
        SerfPiece blockingPiece = new SerfPiece(blockingPos, AbstractPiece.PEICE_TEAM.BLACK); // Opponent team

        gameBoardModel.placePiece(protagPiece);
        gameBoardModel.placePiece(blockingPiece);

        Position expectedPos = gameBoardModel.createPosition(2, 4); // B4 (Forward-Left) - Should still be valid

        // Use getValidSimpleMoves
        List<Position> validMoveSpots = protagPiece.getValidSimpleMoves(gameBoardModel);

        assertNotNull(validMoveSpots, "Valid moves list should not be null.");
        assertEquals(1, validMoveSpots.size(), "Should only have ONE available simple move when one path is blocked by opponent.");
        assertEquals(expectedPos, validMoveSpots.get(0), "The only valid move should be B4.");

        System.out.println("Valid Simple Moves (Blocked by Opponent Piece) Test Passed.");
        gameBoardModel.printBoard();
    }

    // Test for Black piece simple moves
    @Test
    void testBlackPieceSimpleMoves() {
        System.out.println("Testing Black Piece Simple Moves...");
        Position startPos = gameBoardModel.createPosition(5, 5); // E5
        SerfPiece blackPiece = new SerfPiece(startPos, AbstractPiece.PEICE_TEAM.BLACK);
        gameBoardModel.placePiece(blackPiece);

        // Black moves forward (Y decreases)
        Position expectedPos1 = gameBoardModel.createPosition(4, 4); // D4 (Forward-Left for Black)
        Position expectedPos2 = gameBoardModel.createPosition(6, 4); // F4 (Forward-Right for Black)

        List<Position> validMoveSpots = blackPiece.getValidSimpleMoves(gameBoardModel);

        assertNotNull(validMoveSpots, "Valid moves list should not be null.");
        assertEquals(2, validMoveSpots.size(), "Black piece at E5 on empty board should have 2 simple moves.");
        assertTrue(validMoveSpots.contains(expectedPos1), "Valid moves should include D4.");
        assertTrue(validMoveSpots.contains(expectedPos2), "Valid moves should include F4.");

        System.out.println("Black Piece Simple Moves Test Passed.");
        gameBoardModel.printBoard();
    }


    // TODO: Add tests for getValidJumpMoves in a similar fashion
    // - Jump over opponent to empty square
    // - No jump if landing square is occupied
    // - No jump over own piece
    // - No jump if intermediate square is empty
    // - Edge cases (near board edges)

    @AfterAll
    static void breakDown() {
        BoardHelperSingleton.getInstance().closeBoard();
        System.out.println("Board Closed After All Tests.");
    }
}
package ModelTest;

import chkGameUtil.BoardHelperSingleton;
import chkMVC.chModel.Checkers.BoardModel;
import chkMVC.chModel.Checkers.Pieces.AbstractPiece;
import chkMVC.chModel.Checkers.Pieces.SerfPiece;
import chkMVC.chModel.Checkers.Position;
import chkMVC.chModel.Math.Vector2i;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class PieceTest {

    private static BoardModel gameBoardModel;

    @BeforeAll
    static void init()
    {
        gameBoardModel = new BoardModel(8);
    }

    @AfterEach
    void resetBoard()
    {
        gameBoardModel.clearBoard();
    }

    @Test
    void testPieceCreation() {
        SerfPiece newPiece = new SerfPiece(gameBoardModel.createPosition(1, 1), AbstractPiece.PEICE_TEAM.WHITE);
        assertNotNull(newPiece, "Piece should be created successfully.");
    }

    @Test
    void testPieceInitialPosition() {
        SerfPiece piece = new SerfPiece(gameBoardModel.createPosition(3, 3), AbstractPiece.PEICE_TEAM.BLACK);
        assertEquals(3, piece.getPosition().getX());
        assertEquals(3, piece.getPosition().getY());
    }

    @Test
    void testPieceMovement() {
        SerfPiece piece = new SerfPiece(gameBoardModel.createPosition(2, 2), AbstractPiece.PEICE_TEAM.BLACK);

        piece.move(new Vector2i(1, 1));  // Assume move() updates position
        assertEquals(gameBoardModel.createPosition(3, 3), piece.getPosition());
    }

    @Test
    void testPieceTeamAssignment() {
        SerfPiece whitePiece = new SerfPiece(gameBoardModel.createPosition(4, 4), AbstractPiece.PEICE_TEAM.WHITE);
        SerfPiece blackPiece = new SerfPiece(gameBoardModel.createPosition(5, 5), AbstractPiece.PEICE_TEAM.BLACK);

        assertEquals(AbstractPiece.PEICE_TEAM.WHITE, whitePiece.getTeam());
        assertEquals(AbstractPiece.PEICE_TEAM.BLACK, blackPiece.getTeam());
    }

    @Test
    void testInvalidMovement() {
        SerfPiece piece = new SerfPiece(gameBoardModel.createPosition(5, 5), AbstractPiece.PEICE_TEAM.WHITE);

        // Expecting IllegalArgumentException
        assertThrows(IllegalArgumentException.class, () -> {
            piece.move(new Vector2i(8, 8));
        }, "Piece should throw an exception for illegal moves.");
    }

    @AfterAll
    static void breakDown()
    {
        //gameBoardModel.closeBoard();
    }
}
package ModelTest;

import chkMVC.chModel.Checkers.BoardModel;
import chkMVC.chModel.Checkers.Position;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertThrows;

public class PositionTest {

    private static BoardModel gameBoardModel;

    @BeforeAll
    static void start()
    {
        gameBoardModel = new BoardModel(8);
    }

    @Test
    void initGoodPosition()
    {
        Position goodPosition = gameBoardModel.createPosition(4, 4);

        Assertions.assertTrue(goodPosition != null, " Error with position declaration!");
    }

    @Test
    void testLinPositionFromInt()
    {
        Position pA1 = gameBoardModel.positionFromInt(1);
        Assertions.assertEquals(gameBoardModel.createPosition(1, 1), pA1, "Position was not expected.");

        Position pH8 = gameBoardModel.positionFromInt(63);
        Assertions.assertEquals(gameBoardModel.createPosition(8, 8), pH8, "Position was not expected.");
    }

    @Test
    void testInvalidPositionFromInt()
    {
        // Expecting IllegalArgumentException
        assertThrows(IllegalArgumentException.class, () -> {
            gameBoardModel.positionFromInt(65);
        }, "Piece should throw an exception for illegal moves.");

        assertThrows(IllegalArgumentException.class, () -> {
            gameBoardModel.positionFromInt(-1);
        }, "Piece should throw an exception for illegal moves.");
    }

    @AfterAll
    static void breakDown()
    {

    }
}
package NetworkTesting;

import chkNetwork.Server.ServerLogic;
import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.*;

import java.io.*;
import java.net.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeoutException;

//Test Some basic functionality with the test for the network.
public class NetworkChatTest {

    //Set the port and host.
    private static final int PORT = 5000; // Use a potentially different port for tests
    private static final String HOST = "localhost";

    //Keep track of the server.
    private static ServerLogic server;
    private static Thread serverThread; // Keep track of the server thread

    //Initialize the server because this is kind of important for everything
    //(no server = no anything >:()
    @BeforeAll
    static void startServer() throws IOException {
        System.out.println("Starting server for tests on port " + PORT + "...");

        // This starts the server in another thread so we can continue.
        server = new ServerLogic(PORT);
        server.start();

        // Wait a moment for the server socket to bind and start listening.
        // This is crucial to avoid "Connection refused" errors in the first test.
        try {
            Thread.sleep(1000); // Increased sleep to ensure server is ready
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.err.println("Interrupted while waiting for server to start.");
        }
        System.out.println("Server should be running.");
    }

    //Afterwards we can stop the server.
    @AfterAll
    static void stopServer() {
        System.out.println("Stopping server...");
        if (server != null) {
            server.stop(); // Signal the server to stop accepting and close sockets
        }
        if (serverThread != null) {
            // Optionally wait for the server thread to finish, with a timeout
            try {
                serverThread.join(1000); // Wait up to 1 second for the server thread to die
                if (serverThread.isAlive()) {
                    System.err.println("Server thread did not stop gracefully, interrupting...");
                    serverThread.interrupt(); // Force interruption if it didn't stop
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                System.err.println("Interrupted while waiting for server thread to stop.");
                serverThread.interrupt(); // Ensure it's interrupted
            }
        }
        System.out.println("Server stopped.");
        // Add a small delay AFTER stopping to release the port fully before next potential test run
        try { Thread.sleep(500); } catch (InterruptedException e) {}
    }

    // TestClient remains largely the same, but ensure close is robust
    private static class TestClient implements AutoCloseable {
        private Socket socket;
        private PrintWriter out;
        private BufferedReader in;
        final String username; // Make username final

        TestClient(String username) throws IOException {
            this.username = username;
            // Add retry logic for connection refused, just in case server isn't instantly ready
            int attempts = 0;
            while(true) {
                try {
                    socket = new Socket(); // Create unbound socket
                    // Set a connection timeout
                    socket.connect(new InetSocketAddress(HOST, PORT), 1000); // 1 second timeout
                    break; // Connected successfully
                } catch (IOException e) {
                    attempts++;
                    if (attempts >= 5) { // Max 5 attempts
                        System.err.println("Failed to connect client " + username + " after " + attempts + " attempts.");
                        throw e; // Rethrow after max attempts
                    }
                    System.out.println("Connection attempt " + attempts + " failed for " + username + ", retrying...");
                    try { Thread.sleep(200 * attempts); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new IOException("Interrupted during connect retry", ie); }
                }
            }

            out = new PrintWriter(socket.getOutputStream(), true);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            // Send username immediately
            out.println(username);
            System.out.println("Client " + username + " connected and sent username.");
        }

        void sendMessage(String message) {
            if (out != null && !socket.isClosed()) {
                System.out.println(username + " sending: " + message);
                out.println(message);
            } else {
                System.err.println("Warning: Attempted to send message on closed socket for " + username);
            }
        }

        // Reads a single line with a specific timeout.
        String readLineWithTimeout(long timeoutMillis) throws IOException, TimeoutException {
            long deadline = System.currentTimeMillis() + timeoutMillis;
            while (System.currentTimeMillis() < deadline) {
                if (in.ready()) {
                    String line = in.readLine();
                    if (line == null) { // End of stream reached (server likely closed connection)
                        throw new SocketException("Server closed connection while reading.");
                    }
                    System.out.println(username + " received: " + line);
                    return line;
                }
                try {
                    Thread.sleep(50); // Poll interval
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new IOException("Interrupted while waiting to read", e);
                }
            }
            throw new TimeoutException("Timeout waiting for message from server for " + username);
        }

        @Override
        public void close() throws IOException {
            System.out.println("Closing client: " + username);
            // Close resources in reverse order of creation
            // Closing the socket should close the associated streams automatically,
            // but closing them explicitly first can sometimes be safer.
            try { if (out != null) out.close(); } catch (Exception e) { /* Ignore */ }
            try { if (in != null) in.close(); } catch (Exception e) { /* Ignore */ }
            try {
                if (socket != null && !socket.isClosed()) {
                    socket.close();
                }
            } catch (IOException e) {
                System.err.println("Error closing socket for " + username + ": " + e.getMessage());
                // Don't rethrow from close() if possible, but log it.
            } finally {
                // Nullify to prevent reuse
                out = null;
                in = null;
                socket = null;
            }
            System.out.println("Client " + username + " closed.");
        }
    }

    /**
     * Helper method to receive all available messages within a timeout.
     * This reads messages until a TimeoutException occurs on readLineWithTimeout,
     * or until the overall deadline is hit.
     *
     * @param client The TestClient to read from.
     * @param totalTimeoutMillis The maximum time to wait for messages in total.
     * @return A List of messages received within the timeout.
     */
    private List<String> receiveAvailableMessages(TestClient client, long totalTimeoutMillis) throws IOException {
        List<String> received = new ArrayList<>();
        long deadline = System.currentTimeMillis() + totalTimeoutMillis;
        System.out.println("Receiving messages for " + client.username + " (timeout: " + totalTimeoutMillis + "ms)...");

        while (System.currentTimeMillis() < deadline) {
            try {
                // Use a shorter timeout for individual reads to make it responsive
                long remainingTime = deadline - System.currentTimeMillis();
                if (remainingTime <= 0) break;
                // Use a small read timeout (e.g., 100ms) to check if data is there
                String line = client.readLineWithTimeout(Math.min(remainingTime, 200));
                received.add(line);
                // Continue reading immediately if successful
            } catch (TimeoutException e) {
                // This is expected when no more messages are immediately available.
                // We break the loop as we've consumed all currently available messages.
                // System.out.println("Read timeout for " + client.username + ", finished receiving available messages.");
                break;
            } catch (SocketException se) {
                System.out.println("SocketException for " + client.username + " while receiving: " + se.getMessage() + ". Assuming disconnected.");
                break; // Stop reading if socket is closed
            }
            // No need for sleep here, readLineWithTimeout handles waiting
        }
        System.out.println("Finished receiving for " + client.username + ". Got " + received.size() + " messages.");
        return received;
    }

    // Give clients a moment to connect and server to process
    private void waitForNetwork() {
        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt();}
    }


    @Test
    @Timeout(10) // Overall test timeout
    void testClientConnectAndJoinMessage() throws IOException {
        try (TestClient client1 = new TestClient("Alice");
             TestClient client2 = new TestClient("Bob")) {

            waitForNetwork(); // Allow time for connections and initial messages

            // Alice receives initial messages (likely just her own user list initially)
            List<String> aliceInitialMessages = receiveAvailableMessages(client1, 1500);
            // Check if Alice got a user list message after connecting
            assertTrue(aliceInitialMessages.stream().anyMatch(s -> s.contains("Connected users:")),
                    "Alice should receive a user list upon joining.");


            // Bob receives initial messages (should include Alice in the list)
            List<String> bobInitialMessages = receiveAvailableMessages(client2, 1500);
            assertTrue(bobInitialMessages.stream().anyMatch(s -> s.contains("Connected users:") && s.contains("Alice") && s.contains("Bob")),
                    "Bob's user list should contain Alice and Bob. Got: " + bobInitialMessages);


            // Now, check if Alice received the notification about Bob joining.
            // This might have arrived during the initial read or might arrive shortly after.
            List<String> aliceMoreMessages = receiveAvailableMessages(client1, 1000); // Read any further messages
            List<String> allAliceMessages = new ArrayList<>(aliceInitialMessages);
            allAliceMessages.addAll(aliceMoreMessages);

            String expectedJoinMsg = "Bob has joined the chat!";
            assertTrue(allAliceMessages.stream().anyMatch(s -> s.equals(expectedJoinMsg)),
                    "Alice did not receive Bob's join message. Received: " + allAliceMessages);

            // Optional: Check Bob *doesn't* get Alice's join message *after* his initial list
            // This depends heavily on server implementation (when join is broadcast)
            // List<String> bobMoreMessages = receiveAvailableMessages(client2, 500);
            // assertFalse(bobMoreMessages.stream().anyMatch(s -> s.contains("Alice has joined")), "Bob should not receive Alice's join message again");

        }
    }

    @Test
    @Timeout(10)
    void testMessageBroadcast() throws IOException {
        try (TestClient client1 = new TestClient("Charlie");
             TestClient client2 = new TestClient("David")) {

            waitForNetwork(); // Allow time for connections and join broadcasts

            // Consume any initial messages (user lists, join notifications)
            receiveAvailableMessages(client1, 1000);
            receiveAvailableMessages(client2, 1000);

            // Charlie sends a message
            String messageToSend = "Hello everyone!";
            client1.sendMessage(messageToSend);

            waitForNetwork(); // Allow time for broadcast propagation

            // Check messages received AFTER sending
            List<String> charlieReceived = receiveAvailableMessages(client1, 1000);
            List<String> davidReceived = receiveAvailableMessages(client2, 1000);

            String expectedBroadcast = "Charlie: " + messageToSend;

            // Assert that the broadcast message is present in the messages received by *both* clients
            assertTrue(charlieReceived.contains(expectedBroadcast),
                    "Charlie didn't receive own broadcast. Received: " + charlieReceived);
            assertTrue(davidReceived.contains(expectedBroadcast),
                    "David didn't receive Charlie's broadcast. Received: " + davidReceived);
        }
    }

    @Test
    @Timeout(10)
    void testClientLeaveMessage() throws IOException {
        TestClient client1 = null;
        try {
            client1 = new TestClient("Eve");
            waitForNetwork(); // Eve connects

            // Consume Eve's initial messages (user list)
            receiveAvailableMessages(client1, 1000);

            String client2Username = "Frank";
            try (TestClient client2 = new TestClient(client2Username)) {
                waitForNetwork(); // Frank connects, server broadcasts join

                // Consume messages resulting from Frank's join
                // Eve should get "Frank joined", Frank gets user list
                receiveAvailableMessages(client1, 1000); // Clear Eve's buffer (likely contains Frank's join)
                receiveAvailableMessages(client2, 1000); // Clear Frank's buffer (user list)

                // Frank leaves when this block ends
                System.out.println("Frank (client2) is about to leave...");
            } // client2.close() is called here automatically

            waitForNetwork(); // Allow server time to process disconnect and broadcast leave msg

            // Client 1 (Eve) should receive the leave message
            List<String> eveMessagesAfterLeave = receiveAvailableMessages(client1, 2000); // Allow more time for leave msg

            String expectedLeaveMsg = client2Username + " has left the chat.";
            assertTrue(eveMessagesAfterLeave.contains(expectedLeaveMsg),
                    "Client 1 (Eve) did not receive leave message for Frank. Received: " + eveMessagesAfterLeave);

        } finally {
            if (client1 != null) {
                client1.close(); // Ensure client1 is closed even on failure
            }
        }
    }
}
package NetworkTesting;


import chkNetwork.Server.ServerLogic;

public class ServerClientTesting {

    private static ServerLogic server;

}


//Should b there
